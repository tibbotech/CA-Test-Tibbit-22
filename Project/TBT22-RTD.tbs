'***********************************************************************************************************
'			Tibbit #22 Temperature Sensor (RTD-to-Digital Converter)
'***********************************************************************************************************

include "global.tbh"

'--------------------------------------------------------------------
const TBT_RTD_INIT_SIGNATURE=&hB22A
const TBT_RTD_STAMP="TBTRTD> "
const TBT_RTD_CR_LF=chr(13)+chr(10)

'TBT_RTD Co-processor Address
const TBT22_RTD_CODE_W=&h1A
const TBT22_RTD_CODE_R=&h1B

'TBT22 Co-processor Command
const TBT22_RTD_CMD_READ=&h1
const TBT22_RTD_CMD_WRITE=&h2
const TBT22_RTD_CMD_FW_VER=&h3


'TBT22 RTD register address
enum tbt22_rtd_reg_write_addr
	W_REG_ADDR_CONFIGURATION=&h80,
	W_REG_ADDR_HIGH_FAULT_THRESHOLD_MSB=&h83,
	W_REG_ADDR_HIGH_FAULT_THRESHOLD_LSB=&h84,
	W_REG_ADDR_LOW_FAULT_THRESHOLD_MSB=&h85,
	W_REG_ADDR_LOW_FAULT_THRESHOLD_LSB=&h86
end enum

'--------------------------------------------------------------------
'Co-processor utility functions for register access ...
declare sub tbt22_rtd_read_all(byref config as byte, byref rtd as word, byref hi_fault as word, byref lo_fault as word, byref fault as byte)
declare sub tbt22_rtd_reg_write(addr as tbt22_rtd_reg_write_addr, data as byte)
'declare sub tbt22_rtd_delay_in_ms(value as word)

#if TBT_RTD_DEBUG_PRINT=1
	declare sub rtd_debug_print(data as string)
#endif

'--------------------------------------------------------------------
dim i2c_num_rtd as byte
dim rtd_init_flag as word
dim rtd_filter_mode as rtd_conv_mode
'dim tbt22_rtd as tbt22_rtd_type
dim tbt22_normal_0_resistance as real

'==================================================================================================
function tbt_rtd_init(use_ssi as no_yes)as ok_ng
'Call this function to initialize the Tibbit.
'Use_ssi argument specifies whether you want to communicate with this Tibbit using the SSI channel running in the I2C mode (YES), or
'go for direct I/O manipulation a.k.a. bit-banging (NO).
'Note that there is a limited number of SSI channels so if you set use_ssi=YES this function may return NG, meaning that
'there are no free SSI channels left. This doesn't mean failure. Rather, it means that comms will proceed in bit banging mood.
	tbt_rtd_init = OK
	rtd_init_flag = TBT_RTD_INIT_SIGNATURE

	#if TBT_RTD_DEBUG_PRINT = 1
		rtd_debug_print("++++++++++")
	#endif
	
	i2c_num_rtd=si2c_register("TBT22", TBT22_RTD_DATA_PIN, TBT22_RTD_CLK_PIN, use_ssi)
	#if TBT_RTD_DEBUG_PRINT=1
		rtd_debug_print("i2c num:" + str(i2c_num_rtd))
	#endif
	if i2c_num_rtd<4 then
		ssi.channel = i2c_num_rtd
		ssi.enabled = NO
		ssi.baudrate = PL_SSI_BAUDRATES_100kHz	
		ssi.clkmap = TBT22_RTD_CLK_PIN
		ssi.dimap = TBT22_RTD_DATA_PIN
		ssi.domap = TBT22_RTD_DATA_PIN
		ssi.zmode = PL_SSI_ZMODE_ENABLED_ON_ZERO
		ssi.direction = PL_SSI_DIRECTION_LEFT
		ssi.mode = PL_SSI_MODE_2
		ssi.enabled = YES
		io.num = TBT22_RTD_CLK_PIN
		io.enabled = YES
		io.state = HIGH
		io.num = TBT22_RTD_DATA_PIN
		io.enabled = NO
		io.state = HIGH
	else
		if use_ssi = YES then
			tbt_rtd_init = NG
		end if
	end if

	io.num = TBT22_INT_PIN
	io.enabled = NO

	#if TBT_RTD_DEBUG_PRINT = 1
		rtd_debug_print("----------")
	#endif
end function

sub tbt22_rtd_read_all(byref config as byte, byref rtd as word, byref hi_fault as word, byref lo_fault as word, byref fault as byte)
	dim tmp as byte=0

	si2c_get(i2c_num_rtd)

	si2c_start()
	si2c_write(TBT22_RTD_CODE_W)
	si2c_write(TBT22_RTD_CMD_READ)
	si2c_stop()


	si2c_start()
	si2c_write(TBT22_RTD_CODE_R)

	'wait pic co-processor to fetch the data ...
	while (io.lineget(TBT22_INT_PIN) = LOW)
	wend

	config = si2c_read(true)			'byte 0
	tmp = si2c_read(true)				'byte 1
	rtd = tmp * 256 + si2c_read(true)	'byte 2
	tmp = si2c_read(true)				'byte 3
	hi_fault = tmp * 256 + si2c_read(true)'byte 4
	tmp = si2c_read(true)				'byte 5
	lo_fault = tmp * 256 + si2c_read(true)'byte 6
	fault = si2c_read(false)			'byte 7
	si2c_stop()
	while (io.lineget(TBT22_INT_PIN) = LOW)
	wend
end sub

sub tbt22_rtd_reg_write(addr as tbt22_rtd_reg_write_addr, data as byte)
	dim tmr as dword
	si2c_get(i2c_num_rtd)

	si2c_start()
	si2c_write(TBT22_RTD_CODE_W)
	si2c_write(TBT22_RTD_CMD_WRITE)
	si2c_write(addr)
	si2c_write(data)
	si2c_stop()
	while (io.lineget(TBT22_INT_PIN) = LOW)
	wend
end sub

'function tbt22_rtd_config(mode as rtd_conv_mode, byref status as byte, r_in_normal_0_degree_C as real)as ok_ng
function tbt22_rtd_config(mode as rtd_conv_mode, byref status as byte, sensor as rtd_sensor_type)as ok_ng
	dim tmp,count as byte = 0

	status = 0
	tbt22_rtd_config = NG
	if rtd_init_flag <> TBT_RTD_INIT_SIGNATURE then
		#if TBT_RTD_DEBUG_PRINT = 1
			rtd_debug_print("leave, without initialize ")
		#endif
		exit function
	end if

	#if TBT_RTD_DEBUG_PRINT = 1
		if mode = tbt22_conversion_with_50_hz_mode then
			rtd_debug_print("50 Hz mode")
		else
			rtd_debug_print("60 Hz mode")
		end if
	#endif
	rtd_filter_mode = mode

	tbt22_rtd_reg_write(W_REG_ADDR_CONFIGURATION,&h0)

	tbt22_rtd_reg_write(W_REG_ADDR_LOW_FAULT_THRESHOLD_MSB,0)

	tbt22_rtd_reg_write(W_REG_ADDR_LOW_FAULT_THRESHOLD_LSB,0)

	tbt22_rtd_reg_write(W_REG_ADDR_HIGH_FAULT_THRESHOLD_MSB,&hFF)

	tbt22_rtd_reg_write(W_REG_ADDR_HIGH_FAULT_THRESHOLD_LSB,&hFF)

config_write:
	if mode = tbt22_conversion_with_50_hz_mode then
		tmp = &hC3
	else if mode = tbt22_conversion_with_60_hz_mode then
		tmp = &hC2
	end if
	tbt22_rtd_reg_write(W_REG_ADDR_CONFIGURATION,tmp)

	select case sensor
	case PT100:
	#if TBT_RTD_DEBUG_PRINT = 1
		rtd_debug_print("Sensor Type: PT100")
	#endif
		tbt22_normal_0_resistance = 100.0

	case PT200:
	#if TBT_RTD_DEBUG_PRINT = 1
		rtd_debug_print("Sensor Type: PT200")
	#endif
		tbt22_normal_0_resistance = 200.0

	case PT500:
	#if TBT_RTD_DEBUG_PRINT = 1
		rtd_debug_print("Sensor Type: PT500")
	#endif
		tbt22_normal_0_resistance = 500.0

	case PT1000:
	#if TBT_RTD_DEBUG_PRINT = 1
		rtd_debug_print("Sensor Type: PT1000")
	#endif
		tbt22_normal_0_resistance =1000.0

	case else:
	#if TBT_RTD_DEBUG_PRINT = 1
		rtd_debug_print("do not support this sensor")
	#endif
		exit function
	end select

	tbt22_rtd_config = OK
end function

function tbt22_rtd_get_temperature(byref data as real, byref fault_detect as byte, byref fault_status as byte)as ok_ng
	dim i,j as byte
	dim r , hi , lo as word

	tbt22_rtd_get_temperature = NG
	data = 0
	fault_detect = 0
	fault_status = 0

	if rtd_init_flag <> TBT_RTD_INIT_SIGNATURE then
		#if TBT_RTD_DEBUG_PRINT = 1
			rtd_debug_print("leave, without initialize ")
		#endif
		exit function
	end if	

#if TBT_RTD_DEBUG_PRINT = 1
	rtd_debug_print("+++Get Temperature+++")
#endif

	tbt22_rtd_read_all(i, r, hi, lo, j)
#if TBT_RTD_DEBUG_PRINT = 1
	rtd_debug_print(hex(i) + "/" + hex(r) + "/" + hex(hi) + "/" + hex(lo) + "/" + hex(j))
#endif

	fault_detect = i and &h0C
	fault_status = j	

	'D0 of the RTD LSBs register is a Fault bit that indicates whether any RTD faults have been detected.
	if r and &h1 then
		data = hi * 256 + lo
		exit function
	end if
	r = r / 2

leave_with_ok:
	tbt22_rtd_get_temperature=OK
	'The Callendar-Van Dusen equation is commonly used to approximate the RTD curve :
	'
	'	R(T) = R0[1 + aT + bT^2 + c(T - 100)T^3]
	'
	'For more information on measuring with an RTD, ref:
	'
	'	http://newton.ex.ac.uk/teaching/CDHW/Sensors/an046.pdf

	dim a2,b_sq,rtd_resistance,c,d,rtd_rref,resistance as real

	rtd_rref = 4000.0


	a2 = 2.0 * RTD_B
	b_sq = RTD_A * RTD_A

	rtd_resistance = tbt22_normal_0_resistance
	resistance = r * rtd_rref/32768.0

#if TBT_RTD_DEBUG_PRINT = 1
	rtd_debug_print(ftostr(resistance,FTOSTR_MODE_AUTO,7)+" ohms")
	rtd_debug_print("---Get Temperature---")
#endif

	c = 1.0 - (resistance/rtd_resistance)
	d = b_sq - 2.0 * a2 * c

	sqroot(d, data)
	data = (-RTD_A + data)/a2
end function

sub tbt22_rtd_release()
	if rtd_init_flag <> TBT_RTD_INIT_SIGNATURE then exit sub
	rtd_init_flag = &hFFFF
	si2c_release(i2c_num_rtd)
end sub

function tbt22_rtd_fw_version()as string
	dim i as byte = 0
	dim s as string = ""

	if rtd_init_flag <> TBT_RTD_INIT_SIGNATURE then
		#if TBT_RTD_DEBUG_PRINT = 1
			rtd_debug_print("leave, without initialize ")
		#endif
		exit function
	end if

	si2c_get(i2c_num_rtd)

	s=""
	si2c_start()
	si2c_write(TBT22_RTD_CODE_W)
	si2c_write(TBT22_RTD_CMD_FW_VER)
	si2c_stop()
	si2c_start()
	si2c_write(TBT22_RTD_CODE_R)
	for i = 0 to 14
		s = s + chr(si2c_read(TRUE))
	next i
	s = s + chr(si2c_read(FALSE))
	si2c_stop()

	tbt22_rtd_fw_version = s
end function

#if TBT_RTD_DEBUG_PRINT = 1
sub rtd_debug_print(data as string)
	sys.debugprint(TBT_RTD_STAMP + data + TBT_RTD_CR_LF)
end sub
#endif
